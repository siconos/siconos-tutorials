# Copyright (C) INRIA 1999-2005
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 as published
# by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
# Public License for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# 
# Author(s): Pierre-Brice Wieber
# Affiliation(s): INRIA, team BIPOP
# Email(s): Pierre-Brice.Wieber@inria.fr
# 
# Description:
# 
# Modifications:
# $Log$
# Revision 1.3  2005/07/15 05:38:39  wieber
# Explicit optimization in the Inertia and NLEffects code generation.
#
# Revision 1.2  2005/04/18 15:55:15  billet
# includes in files generated by maple
#
# Revision 1.1.1.1  2005/02/08 13:05:36  rpissard
# version start HuMAnS
#
# 

printf("        -------------------------------------------\n");
printf("                        HuMAnS-1.0\n");
printf("               Maple C code generation for\n");
printf("           A Scilab toolbox for Humanoid Motion\n");
printf("                  Analysis and simulation\n");
printf("               Copyright (C) INRIA 1999-2005\n");
printf("        -------------------------------------------\n");

with(linalg):
with(codegen, C, makeproc):


REGISTERING := false:

Register := proc(x)
global REGISTERING, RegisteredList;

	if type(x, atomic) or type(-x, atomic) or not REGISTERING then
		RETURN(x):
	else
		RegisteredList := [op(RegisteredList), x]:
		RETURN(tmp||(vectdim(RegisteredList))):
	end:
end:

OptimizeRegisteredList := proc(RegisteringResult)
global RegisteredList;
local i, j, useful;

	for i from vectdim(RegisteredList) by -1 to 1 do
		useful := false:
		for j from 1 to vectdim(RegisteringResult) while not useful do
			useful := useful or has(RegisteringResult[j], tmp||(i)):
		end do:
		for j from i+1 to vectdim(RegisteredList) while not useful do
			useful := useful or has(RegisteredList[j], tmp||(i)):
		end do:
		if not useful then
			RegisteredList := subsop(i=0, RegisteredList):
		end:
	end do:
end:

PrintRegisteredList := proc(fd)
global RegisteredList;
local i;

	for i from 1 to vectdim(RegisteredList) do
		if RegisteredList[i] <> 0 then
			fprintf(fd, "  double %s", CodeGeneration[C](
				map(y->subs({seq(cos(q[i+1])=C||i, i=0..NDDL-1),
					seq(sin(q[i+1])=S||i, i=0..NDDL-1)}, y), RegisteredList[i]),
				resultname = "tmp"||(i), output = string,
				coercetypes = false, deducetypes = false)):
		end:
	end do:
end:

GenerateSC := proc(fd)
local i;

	for i from 0 to NDDL-1 do
		fprintf(fd, "  double C%d = cos(q[%d]);\n", i, i):
		fprintf(fd, "  double S%d = sin(q[%d]);\n", i, i):
	end do:
end:

FrameMatrix := proc(k);

	RETURN(matrix([[cos(theta_||(k)), -sin(theta_||(k)), 0, r_||(k)],
			[cos(alpha_||(k))*sin(theta_||(k)), cos(alpha_||(k))*cos(theta_||(k)), -sin(alpha_||(k)), -sin(alpha_||(k))*lambda_||(k)],
			[sin(alpha_||(k))*sin(theta_||(k)), sin(alpha_||(k))*cos(theta_||(k)), cos(alpha_||(k)), cos(alpha_||(k))*lambda_||(k)],
			[0, 0, 0, 1]])):
end:

NLEffectsRecursion := proc(j, Omegai, Omegadoti, Accelerationi, Ui)
local FrameChange, R, P, RTRdot, RTPdot, RTOmegai, Omegaj,
	Omegadotj, Accelerationj, Uj, F, M, Gamma, k, Result, RF;

	FrameChange := FrameMatrix(j):
	R := submatrix(FrameChange, 1..3, 1..3):
	P := subvector(FrameChange, 1..3, 4):
	RTRdot := map(simplify, evalm(transpose(R)&*
		map(x->subs({seq(q[i](t)=q[i], i=1..NDDL),
		seq(diff(q[i](t), t)=qdot[i], i=1..NDDL)},
		diff(subs({seq(q[i]=q[i](t), i=1..NDDL)}, x), t)), R))):
	RTRdot := Vector([RTRdot[3, 2], RTRdot[1, 3], RTRdot[2, 1]]):
	RTPdot := evalm(transpose(R)&*
		map(x->subs({seq(q[i](t)=q[i], i=1..NDDL),
		seq(diff(q[i](t), t)=qdot[i], i=1..NDDL)},
		diff(subs({seq(q[i]=q[i](t), i=1..NDDL)}, x), t)), P)):

	RTOmegai := map(Register, evalm(transpose(R)&*Omegai)):
	Omegaj := evalm(RTOmegai+RTRdot):
	Omegadotj := map(Register, evalm(transpose(R)&*Omegadoti+crossprod(RTOmegai, RTRdot))):
	Accelerationj := map(Register, evalm(transpose(R)&*(Accelerationi+Ui&*P)+2*crossprod(RTOmegai, RTPdot))):

	Uj := map(Register, matrix([[-Omegaj[3]^2-Omegaj[2]^2, -Omegadotj[3]+Omegaj[2]*Omegaj[1], Omegadotj[2]+Omegaj[3]*Omegaj[1]],
					[Omegadotj[3]+Omegaj[2]*Omegaj[1], -Omegaj[3]^2-Omegaj[1]^2, -Omegadotj[1]+Omegaj[3]*Omegaj[2]],
					[-Omegadotj[2]+Omegaj[3]*Omegaj[1], Omegadotj[1]+Omegaj[3]*Omegaj[2], -Omegaj[2]^2-Omegaj[1]^2]])):

	F := map(Register, evalm(m_||(j)*Accelerationj+Uj&*(m_||(j)*G_||(j)))):
	M := map(Register, evalm(IO_||(j)&*Omegadotj+crossprod(Omegaj, IO_||(j)&*Omegaj)+crossprod(cat(m_,j)*cat(G_,j), Accelerationj))):
	Gamma := vector(NDDL, 0):

	for k from 1 to NSOL
	do
		if ref_||(k) = j
		then
			Result := NLEffectsRecursion(k, Omegaj, Omegadotj, Accelerationj, Uj):
			F := map(Register, evalm(F+Result[1])):
			M := map(Register, evalm(M+Result[2])):
			Gamma := map(Register, evalm(Gamma+Result[3])):
		fi:
	od:

	Gamma := map(Register, evalm(Gamma+transpose(jacobian(RTRdot, qdot))&*M+transpose(jacobian(RTPdot, qdot))&*F)):
	RF := map(Register, evalm(R&*F));
	#print(map(x->if x=0 then 0 else 1 fi, Gamma));
	print(`Frame `||(j));
	RETURN([evalm(RF), map(Register, evalm(R&*M+crossprod(P, RF))), evalm(Gamma)]):
end:

NLEffectsVector := proc()
local Result;

	print(`NLEffects Vector`);
	Result := NLEffectsRecursion(1, [0, 0, 0], [0, 0, 0], evalm(-Gravity), [[0, 0, 0], [0, 0, 0], [0, 0, 0]]):
	RETURN(Result[3]):
end:



JacobianQNLEffectsMatrix := proc(NLE)
local nleffect, y;
       
        print(`NLEffects Jacobian`);
        y := convert(NLE, matrix):
        RETURN(jacobian(col(y,1), q)):
end:

JacobianVelocityNLEffectsMatrix := proc(NLE)
local nleffects, y;
       
        print(`NLEffects Velocity Jacobian`);
        y := convert(NLE, matrix):
        RETURN(jacobian(col(y,1), qdot)):
end:


GenerateNLEffectsVector := proc(NLE)
global REGISTERING, RegisteredList;
local fd, FileName, CodeList, CodeLine, i, N;

	FileName := "NLEffects.c":
	REGISTERING := true:
	RegisteredList := []:
	N := convert(evalm(NLE+blockmatrix(2, 1, [map(y->subs({seq(cos(q[i+1])=C||i, i=0..NDDL-1),
		seq(sin(q[i+1])=S||i, i=0..NDDL-1)}, y), RotorNLEffectsVector()), vector(6, 0)])), vector):
	print(`Optimizing...`);
	OptimizeRegisteredList(N):
	CodeList := [codegen[optimize](N)]:
	unassign(N):
	print(`Generating "`||(FileName)||`"`);
	fd := fopen(FileName, WRITE):
	fprintf(fd, "#include <math.h>\n"):
	fprintf(fd, "#include ""LagrangianModel.h""\n\n"):
	fprintf(fd, "void NLEffects(N, q, qdot)\n"):
	fprintf(fd, "double N[%d];\n", NDDL):
	fprintf(fd, "double q[%d];\n", NDDL):
	fprintf(fd, "double qdot[%d];\n", NDDL):
	fprintf(fd, "{\n"):
	GenerateSC(fd):
	PrintRegisteredList(fd):
	for i from 1 to vectdim(CodeList) do
		if i <= vectdim(CodeList)-NDDL then
			CodeLine := convert(CodeList[i], list):
			fprintf(fd, "  double %s", CodeGeneration[C](CodeLine[2], resultname = CodeLine[1], output = string,
				coercetypes = false, deducetypes = false)):
		else
			fprintf(fd, "  %s", CodeGeneration[C]([CodeList[i]], output = string,
				coercetypes = false, deducetypes = false)):
		end:
	end do:
	fprintf(fd, "}\n"):
	fclose(fd):
	REGISTERING := false:
end:


GenerateJacobianQNLEffectsMatrix := proc(NLE)
global REGISTERING, RegisteredList;
local fd, FileName, CodeList, CodeLine, i, JN;

	FileName := "JacobianQNLEffects.c":
	REGISTERING := true:
	RegisteredList := []:
	JN := convert(evalm(JacobianQNLEffectsMatrix(NLE)), vector):
	print(`Optimizing...`);
	OptimizeRegisteredList(JN):
	CodeList := [codegen[optimize](JN)]:
	unassign(N):
	print(`Generating "`||(FileName)||`"`);
	fd := fopen(FileName, WRITE):
	fprintf(fd, "#include <math.h>\n"):
	fprintf(fd, "#include ""LagrangianModel.h""\n\n"):
	fprintf(fd, "void JacobianQNLEffects(JN, q, qdot)\n"):
	fprintf(fd, "double JN[%d];\n", NDDL*NDDL):
	fprintf(fd, "double q[%d];\n", NDDL):
	fprintf(fd, "double qdot[%d];\n", NDDL):
	fprintf(fd, "{\n"):
#	GenerateSC(fd):
	PrintRegisteredList(fd):
	for i from 1 to vectdim(CodeList) do
		if i <= vectdim(CodeList)-NDDL*NDDL then
			CodeLine := convert(CodeList[i], list):
			fprintf(fd, "  double %s", CodeGeneration[C](CodeLine[2], resultname = CodeLine[1], output = string,
				coercetypes = false, deducetypes = false)):
		else
			fprintf(fd, "  %s", CodeGeneration[C]([CodeList[i]], output = string,
				coercetypes = false, deducetypes = false)):
		end:
	end do:
	fprintf(fd, "}\n"):
	fclose(fd):
	REGISTERING := false:
end:

GenerateJacobianVNLEffectsMatrix := proc(NLE)
global REGISTERING, RegisteredList;
local fd, FileName, CodeList, CodeLine, i, JN;

	FileName := "JacobianVNLEffects.c":
	REGISTERING := true:
	RegisteredList := []:
	JN := convert(evalm(JacobianVelocityNLEffectsMatrix(NLE)), vector):
	print(`Optimizing...`);
	OptimizeRegisteredList(JN):
	CodeList := [codegen[optimize](JN)]:
	unassign(N):
	print(`Generating "`||(FileName)||`"`);
	fd := fopen(FileName, WRITE):
	fprintf(fd, "#include <math.h>\n"):
	fprintf(fd, "#include ""LagrangianModel.h""\n\n"):
	fprintf(fd, "void JacobianVNLEffects(JN, q, qdot)\n"):
	fprintf(fd, "double JN[%d];\n", NDDL*NDDL):
	fprintf(fd, "double q[%d];\n", NDDL):
	fprintf(fd, "double qdot[%d];\n", NDDL):
	fprintf(fd, "{\n"):
#	GenerateSC(fd):
	PrintRegisteredList(fd):
	for i from 1 to vectdim(CodeList) do
		if i <= vectdim(CodeList)-NDDL*NDDL then
			CodeLine := convert(CodeList[i], list):
			fprintf(fd, "  double %s", CodeGeneration[C](CodeLine[2], resultname = CodeLine[1], output = string,
				coercetypes = false, deducetypes = false)):
		else
			fprintf(fd, "  %s", CodeGeneration[C]([CodeList[i]], output = string,
				coercetypes = false, deducetypes = false)):
		end:
	end do:
	fprintf(fd, "}\n"):
	fclose(fd):
	REGISTERING := false:
end:



InertiaRecursion := proc(j)
local FrameChange, R, P, RTRdot, RTPdot, JR, JP, m, mG, IO, F, M, Inertia, k, Result, mGx, FTJP, MTJR, Fadd, Madd, RmG, RmGx, RF, Px, PxRmGx;

	FrameChange := FrameMatrix(j):
	R := submatrix(FrameChange, 1..3, 1..3):
	P := subvector(FrameChange, 1..3, 4):
	RTRdot := map(simplify, evalm(transpose(R)&*
		map(x->subs({seq(q[i](t)=q[i], i=1..NDDL),
		seq(diff(q[i](t), t)=qdot[i], i=1..NDDL)},
		diff(subs({seq(q[i]=q[i](t), i=1..NDDL)}, x), t)), R))):
	RTPdot := evalm(transpose(R)&*
		map(x->subs({seq(q[i](t)=q[i], i=1..NDDL),
		seq(diff(q[i](t), t)=qdot[i], i=1..NDDL)},
		diff(subs({seq(q[i]=q[i](t), i=1..NDDL)}, x), t)), P)):
	JR := jacobian(vector([RTRdot[3, 2], RTRdot[1, 3], RTRdot[2, 1]]), qdot):
	JP := jacobian(RTPdot, qdot):

	m := m_||(j):
	mG := evalm(m*G_||(j)):
	IO := evalm(IO_||(j)):
	F := matrix(3, NDDL, 0):
	M := matrix(3, NDDL, 0):
	Inertia := matrix(NDDL, NDDL, 0):

	for k from 1 to NSOL
	do
		if ref_||(k) = j
		then
			Result := InertiaRecursion(k):
			m := evalm(m+Result[1]):
			mG := map(Register, evalm(mG+Result[2])):
			IO := map(Register, evalm(IO+Result[3])):
			F := map(Register, evalm(F+Result[4])):
			M := map(Register, evalm(M+Result[5])):
			Inertia := evalm(Inertia+Result[6]):
		fi:
	od:

	mGx := matrix([[0, -mG[3], mG[2]], [mG[3], 0, -mG[1]], [-mG[2], mG[1], 0]]):
	FTJP := map(Register, evalm(transpose(F)&*JP)):
	MTJR := map(Register, evalm(transpose(M)&*JR)):
	Fadd := map(Register, evalm(m*JP-mGx&*JR)):
	Madd := map(Register, evalm(IO&*JR+mGx&*JP)):
	Inertia := evalm(Inertia+FTJP+transpose(FTJP)+MTJR+transpose(MTJR)+transpose(Fadd)&*JP+transpose(Madd)&*JR):
	F := evalm(F+Fadd):
	M := evalm(M+Madd):
	RmG := map(Register, evalm(R&*mG)):
	RmGx := matrix([[0, -RmG[3], RmG[2]], [RmG[3], 0, -RmG[1]], [-RmG[2], RmG[1], 0]]):
	RF := map(Register, evalm(R&*F)):
	Px := matrix([[0, -P[3], P[2]], [P[3], 0, -P[1]], [-P[2], P[1], 0]]):
	PxRmGx := map(Register, evalm(Px&*RmGx)):
	print(`Frame `||(j));
	RETURN([m, evalm(RmG+m*P), evalm(R&*map(Register, evalm(IO&*transpose(R)))-m*Px&*Px-PxRmGx-transpose(PxRmGx)), evalm(RF), evalm(R&*M+Px&*RF), evalm(Inertia)]):
end:

InertiaMatrix := proc()
local Result;

	print(`Inertia Matrix`);
	Result := InertiaRecursion(1):
	RETURN(Result[6]):
end:

GenerateInertiaMatrix := proc()
global REGISTERING, RegisteredList;
local fd, FileName, CodeList, CodeLine, i, M;

	FileName := "Inertia.c":
	REGISTERING := true:
	RegisteredList := []:
	M := convert(evalm(InertiaMatrix()+blockmatrix(2, 2, [map(y->subs({seq(cos(q[i+1])=C||i, i=0..NDDL-1),
		seq(sin(q[i+1])=S||i, i=0..NDDL-1)}, y), RotorInertiaMatrix()), matrix(15, 6, 0), matrix(6, 15, 0), matrix(6, 6, 0)])), vector):
	print(`Optimizing...`);
	OptimizeRegisteredList(M):
	CodeList := [codegen[optimize](M)]:
	unassign(M):
	print(`Generating "`||(FileName)||`"`);
	fd := fopen(FileName, WRITE):
	fprintf(fd, "#include <math.h>\n"):
	fprintf(fd, "#include ""LagrangianModel.h""\n\n"):
	fprintf(fd, "void Inertia(M, q)\n"):
	fprintf(fd, "double M[%d];\n", NDDL^2):
	fprintf(fd, "double q[%d];\n", NDDL):
	fprintf(fd, "{\n"):
	GenerateSC(fd):
	PrintRegisteredList(fd):
	for i from 1 to vectdim(CodeList) do
		if i <= vectdim(CodeList)-NDDL*NDDL then
			CodeLine := convert(CodeList[i], list):
			fprintf(fd, "  double %s", CodeGeneration[C](CodeLine[2], resultname = CodeLine[1], output = string,
				coercetypes = false, deducetypes = false)):
		else
			fprintf(fd, "  %s", CodeGeneration[C]([CodeList[i]], output = string,
				coercetypes = false, deducetypes = false)):
		end:
	end do:
	fprintf(fd, "}\n"):
	fclose(fd):
	REGISTERING := false:
end:

RotorPosition := proc()
local xE, xI, xE0, xI0, thetaE, thetaI, xGe, xGe0, thetaGe, xH, xH0, thetaH, xG, xD, xG0, xD0, thetaG, thetaD, theta;

	xE := -(bC*cos(qF)-dC*sin(qF))*cos(qS+gammaC)+cC*sin(qS+gammaC)+(lC^2-(eC-(bC*cos(qF)-dC*sin(qF))*sin(qS+gammaC)-cC*cos(qS+gammaC))^2-(hC-bC*sin(qF)-dC*cos(qF))^2)^(1/2):
	xI := -(bC*cos(qF)+dC*sin(qF))*cos(qS+gammaC)+cC*sin(qS+gammaC)+(lC^2-(eC-(bC*cos(qF)+dC*sin(qF))*sin(qS+gammaC)-cC*cos(qS+gammaC))^2-(dC*cos(qF)-bC*sin(qF)-hC)^2)^(1/2):
	xE0 := subs({qF=0,qS=0},xE):
	xI0 := subs({qF=0,qS=0},xI):
	thetaE := (xE-xE0)/pC:
	thetaI := (xI-xI0)/pC:

	xGe := RG*cos(qG+gammaG-phiG)+(lG^2-(eG-RG*sin(qG+gammaG-phiG))^2)^(1/2):
	xGe0 := subs({qG=0},xGe):
	thetaGe := (xGe-xGe0)/pG:

	xH := -RH*cos(1/2*Pi+qH+phiH-gammaH)+(lH^2-(RH*sin(1/2*Pi+qH+phiH-gammaH)-eH)^2)^(1/2):
	xH0 := subs({qH=0},xH):
	thetaH := (xH-xH0)/pH:

	xG := (-dL*sin(q16)+bL*cos(q16))*cos(q17+gammaL)+cL*sin(q17+gammaL)+(lL^2-(eL+(-dL*sin(q16)+bL*cos(q16))*sin(q17+gammaL)-cL*cos(q17+gammaL))^2-(dL*cos(q16)+bL*sin(q16)-hL)^2)^(1/2):
	xD := (dL*sin(q16)+bL*cos(q16))*cos(q17+gammaL)+cL*sin(q17+gammaL)+(lL^2-(eL+(dL*sin(q16)+bL*cos(q16))*sin(q17+gammaL)-cL*cos(q17+gammaL))^2-(dL*cos(q16)-bL*sin(q16)-hL)^2)^(1/2):
	xG0 := subs({q16=0,q17=0},xG):
	xD0 := subs({q16=0,q17=0},xD):
	thetaG := (xG-xG0)/(-pL):
	thetaD := (xD-xD0)/(-pL):

	theta := vector(15, 0);
	theta[1] := -subs({qF = q[1], qS = q[2]}, thetaE):
	theta[2] := -subs({qF = q[1], qS = q[2]}, thetaI):
	theta[3] := -subs({qG = q[3]}, thetaGe):
	theta[4] := -subs({qH = q[4]}, thetaH):
	theta[5] := -subs({qF = q[5], qS = q[6]}, thetaI):
	theta[6] := -subs({qF = q[5], qS = q[6]}, thetaE):
	theta[7] := -subs({qG = q[7]}, thetaGe):
	theta[8] := -subs({qH = q[8]}, thetaH):
	theta[9] := +271.16*q[9]:
	theta[10] := +203.79*q[10]:
	theta[11] := +271.16*q[11]:
	theta[12] := -203.79*q[12]:
	theta[13] := -191.05*q[13]:
	theta[14] := -subs({q16 = q[14], q17 = q[15]}, thetaD):
	theta[15] := -subs({q16 = q[14], q17 = q[15]}, thetaG):
	RETURN(evalm(theta)):
end:

RotorJacobian := proc();

	RETURN(submatrix(jacobian(RotorPosition(), q), 1..15, 1..15)):
end:

RotorInertiaMatrix := proc()
local RotorInertias;

	RotorInertias := evalm(diag(3.5, 3.5, 7, 7, 3.5, 3.5, 7, 7, 3.5, 1.8, 3.5, 1.8, 1.8, 1.8, 1.8)*1e-5):
	RETURN(evalm(transpose(RotorJacobian())&*RotorInertias&*RotorJacobian())):
end:

RotorNLEffectsVector := proc() option remember;
local RotorInertias;

	RotorInertias := evalm(diag(3.5, 3.5, 7, 7, 3.5, 3.5, 7, 7, 3.5, 1.8, 3.5, 1.8, 1.8, 1.8, 1.8)*1e-5):
	RETURN(evalm(transpose(RotorJacobian())&*RotorInertias&*map(x->subs({seq(q[i](t)=q[i], i=1..15), seq(diff(q[i](t), t)=qdot[i], i=1..15), seq(diff(q[i](t), t, t)=0, i=1..15)}, diff(subs({seq(q[i]=q[i](t), i=1..15)}, x), t, t)), RotorPosition()))):
end:

COMRecursion := proc(j)
local FrameChange, R, P, m, mG, k, Result;

	FrameChange := FrameMatrix(j):
	R := submatrix(FrameChange, 1..3, 1..3):
	P := subvector(FrameChange, 1..3, 4):
	m := m_||(j):
	mG := evalm(m*G_||(j)):
	for k from 1 to NSOL
	do
		if ref_||(k) = j
		then
			Result := COMRecursion(k):
			m := evalm(m+Result[1]):
			mG := evalm(mG+Result[2]):
		fi:
	od:
	RETURN([m, evalm(R&*mG+m*P)]):
end:

COMPosition := proc()
local Result;

	print(`COM Position`);
	Result := COMRecursion(1):
	RETURN(evalm(Result[2]/Result[1])):
end:

TagPosition := proc(k) option remember;
local j, matrice, trans, rot;

	j := reftag_||(k):
	matrice := FrameMatrix(j):
	while ref_||(j) > 0 do
		j := ref_||(j):
		matrice := evalm(FrameMatrix(j)&*matrice):
	end:
	trans := subvector(matrice, 1..3, 4):
	rot := submatrix(matrice, 1..3, 1..3):
	RETURN(evalm(trans + rot &* tag_||(k))):
end:

TagMatrix := proc() option remember;

	print(`Tag Matrix`);
	RETURN(matrix([seq(TagPosition(i), i=1..NTAG), COMPosition()])):
end:

ContactVector := proc() option remember;
local contact;

	print(`Contact Vector`);
	contact := matrix([seq(TagPosition(i), i=points_contact)]):
	RETURN(stackmatrix(seq(matrix(vectdim(points_contact), 1, col(contact, i)), i=1..3))):
end:

ContactJacobianMatrix := proc() option remember;
local contact;

	contact := ContactVector():
	print(`Contact Jacobian`);
	RETURN(jacobian(col(contact, 1), q)):
end:

ContactHessianVector := proc() option remember;
local contact;

	contact := ContactVector():
	print(`Contact Hessian`);
	RETURN(map(x->subs({seq(q[i](t)=q[i],i=1..NDDL)},
		subs({seq(diff(q[i](t),t)=qdot[i],i=1..NDDL)},
		diff(subs({seq(diff(q[i](t),t)=qdot[i],i=1..NDDL)},
		diff(subs({seq(q[i]=q[i](t),i=1..NDDL)},x),t)),t))), contact)):
end:

GenerateModel := proc()
local fd, T, Tags, M, Inertia, NLE, NLEffects, CC, Contact, CH, ContactHessian,
	CJ, ContactJacobian, NJ, NVJ, JacobianVNLEffects;
global q, qdot;

	T := TagMatrix():
	print(`Writing file "Tags.c"`):
	T := convert(transpose(T), vector):
	Tags := makeproc(T, [T, q::array(1..vectdim(q))]):
	fd := fopen("Tags.c",WRITE);
  fprintf(fd,"#include \"../LagrangianModel.h\"\n"):
	fclose(fd):
	C(Tags, optimized, filename="Tags.c"):

	GenerateInertiaMatrix():

	NLE := NLEffectsVector():

	GenerateNLEffectsVector(NLE):

        GenerateJacobianQNLEffectsMatrix(NLE):

        GenerateJacobianVNLEffectsMatrix(NLE):

	CC := ContactVector():
	print(`Writing file "Contact.c"`):
	CC := convert(transpose(CC), vector):
	Contact := makeproc(CC, [CC, q::array(1..vectdim(q))]):
	fd := fopen("Contact.c",WRITE);
  fprintf(fd,"#include \"LagrangianModel.h\"\n"):
	fclose(fd):
	C(Contact, optimized, filename="Contact.c"):

#	CH := ContactHessianVector():
#	print(`Writing file "ContactHessian.c"`):
#	CH := convert(transpose(CH), vector):
#	ContactHessian := makeproc(CH, [CH, q::array(1..vectdim(q)), qdot::array(1..vectdim(qdot))]):
#	fd := fopen("ContactHessian.c",WRITE);
#  fprintf(fd,"#include \"LagrangianModel.h\"\n"):
#	fclose(fd):
#	C(ContactHessian, optimized, filename="ContactHessian.c"):

	CJ := ContactJacobianMatrix():
	print(`Writing file "ContactJacobian.c"`):
	CJ := convert(transpose(CJ), vector):
	ContactJacobian := makeproc(CJ, [CJ, q::array(1..vectdim(q))]):
	fd := fopen("ContactJacobian.c",WRITE);
  fprintf(fd,"#include \"LagrangianModel.h\"\n"):
	fclose(fd):
	C(ContactJacobian, optimized, filename="ContactJacobian.c"):
end:

